void	calc(t_mlx *img)
{
	int	x;

	x = 0;
	if (img->re_buf == 1)
	{
		for (int i = 0; i < HEIGHT; i++)
		{
			for (int j = 0; j < WIDTH; j++)
			{
				img->buf[i][j] = 0;
			}
		}
		img->re_buf = 0;
	}
	while (x < WIDTH)
	{
		double cameraX = 2 * x / (double)WIDTH - 1;
		double rayDirX = img->dirX + img->planeX * cameraX;
		double rayDirY = img->dirY + img->planeY * cameraX;
		
		int mapX = (int)img.posX;
		int mapY = (int)img.posY;

		//length of ray from current position to next x or y-side
		double sideDistX;
		double sideDistY;
		
		 //length of ray from one x or y-side to next x or y-side
		double deltaDistX = fabs(1 / rayDirX);
		double deltaDistY = fabs(1 / rayDirY);
		double perpWallDist;
		
		//what direction to step in x or y-direction (either +1 or -1)
		int stepX;
		int stepY;
		
		int hit = 0; //was there a wall hit?
		int side; //was a NS or a EW wall hit?

		if (rayDirX < 0)
		{
			stepX = -1;
			sideDistX = (img.posX - mapX) * deltaDistX;
		}
		else
		{
			stepX = 1;
			sideDistX = (mapX + 1.0 - img.posX) * deltaDistX;
		}
		if (rayDirY < 0)
		{
			stepY = -1;
			sideDistY = (img.posY - mapY) * deltaDistY;
		}
		else
		{
			stepY = 1;
			sideDistY = (mapY + 1.0 - img.posY) * deltaDistY;
		}

		while (hit == 0)
		{
			//jump to next map square, OR in x-direction, OR in y-direction
			if (sideDistX < sideDistY)
			{
				sideDistX += deltaDistX;
				mapX += stepX;
				side = 0;
			}
			else
			{
				sideDistY += deltaDistY;
				mapY += stepY;
				side = 1;
			}
			//Check if ray has hit a wall
			if (worldMap[mapX][mapY] > 0) hit = 1;
		}
		if (side == 0)
			perpWallDist = (mapX - img.posX + (1 - stepX) / 2) / rayDirX;
		else
			perpWallDist = (mapY - img.posY + (1 - stepY) / 2) / rayDirY;

		//Calculate HEIGHT of line to draw on screen
		int lineHEIGHT = (int)(HEIGHT / perpWallDist);

		//calculate lowest and highest pixel to fill in current stripe
		int drawStart = -lineHEIGHT / 2 + HEIGHT / 2;
		if(drawStart < 0)
			drawStart = 0;
		int drawEnd = lineHEIGHT / 2 + HEIGHT / 2;
		if(drawEnd >= HEIGHT)
			drawEnd = HEIGHT - 1;

		// texturing calculations
		int texNum = worldMap[mapX][mapY];

		// calculate value of wallX
		double wallX;
		if (side == 0)
			wallX = img.posY + perpWallDist * rayDirY;
		else
			wallX = img.posX + perpWallDist * rayDirX;
		wallX -= floor(wallX);

		// x coordinate on the texture
		int texX = (int)(wallX * (double)texWIDTH);
		if (side == 0 && rayDirX > 0)
			texX = texWIDTH - texX - 1;
		if (side == 1 && rayDirY < 0)
			texX = texWIDTH - texX - 1;

		// How much to increase the texture coordinate perscreen pixel
		double step = 1.0 * TEXT_HEIGHT / lineHEIGHT;
		// Starting texture coordinate
		double texPos = (drawStart - HEIGHT / 2 + lineHEIGHT / 2) * step;
		for (int y = drawStart; y < drawEnd; y++)
		{
			// Cast the texture coordinate to integer, and mask with (TEXT_HEIGHT - 1) in case of overflow
			int texY = (int)texPos & (TEXT_HEIGHT - 1);
			texPos += step;
			int color = img->texture[texNum][TEXT_HEIGHT * texY + texX];
			// make color darker for y-sides: R, G and B byte each divided through two with a "shift" and an "and"
			if (side == 1)
				color = (color >> 1) & 8355711;
			img->buf[y][x] = color;
			img->re_buf = 1;
		}
		x++;
	}
}

int	main_loop(t_mlx *img)
{
	calc(img);
	draw(img);
	return (0);
}

int	key_press(int key, t_mlx *img)
{
	if (key == K_W)
	{
		if (!worldMap[(int)(img.posX + img->dirX * img->moveSpeed)][(int)(img.posY)])
			img.posX += img->dirX * img->moveSpeed;
		if (!worldMap[(int)(img.posX)][(int)(img.posY + img->dirY * img->moveSpeed)])
			img.posY += img->dirY * img->moveSpeed;
	}
	//move backwards if no wall behind you
	if (key == K_S)
	{
		if (!worldMap[(int)(img.posX - img->dirX * img->moveSpeed)][(int)(img.posY)])
			img.posX -= img->dirX * img->moveSpeed;
		if (!worldMap[(int)(img.posX)][(int)(img.posY - img->dirY * img->moveSpeed)])
			img.posY -= img->dirY * img->moveSpeed;
	}
	//rotate to the right
	if (key == K_D)
	{
		//both camera direction and camera plane must be rotated
		double oldDirX = img->dirX;
		img->dirX = img->dirX * cos(-img->rotSpeed) - img->dirY * sin(-img->rotSpeed);
		img->dirY = oldDirX * sin(-img->rotSpeed) + img->dirY * cos(-img->rotSpeed);
		double oldPlaneX = img->planeX;
		img->planeX = img->planeX * cos(-img->rotSpeed) - img->planeY * sin(-img->rotSpeed);
		img->planeY = oldPlaneX * sin(-img->rotSpeed) + img->planeY * cos(-img->rotSpeed);
	}
	//rotate to the left
	if (key == K_A)
	{
		//both camera direction and camera plane must be rotated
		double oldDirX = img->dirX;
		img->dirX = img->dirX * cos(img->rotSpeed) - img->dirY * sin(img->rotSpeed);
		img->dirY = oldDirX * sin(img->rotSpeed) + img->dirY * cos(img->rotSpeed);
		double oldPlaneX = img->planeX;
		img->planeX = img->planeX * cos(img->rotSpeed) - img->planeY * sin(img->rotSpeed);
		img->planeY = oldPlaneX * sin(img->rotSpeed) + img->planeY * cos(img->rotSpeed);
	}
	if (key == K_ESC)
		exit(0);
	mlx_clear_window(img->mlx, img->win);
	main_loop(img);
	return (0);
}

int	main(void)
{
	t_mlx img;
	img.mlx = mlx_init();

	img.posX = 22.0;
	img.posY = 11.5;
	img.dirX = -1.0;
	img.dirY = 0.0;
	img.planeX = 0.0;
	img.planeY = 0.66;
	img.re_buf = 0;

	img.buf = (int **)malloc(sizeof(int *) * HEIGHT);
	for (int i = 0; i < HEIGHT; i++)
	{
		img.buf[i] = (int *)malloc(sizeof(int) * WIDTH);
	}

	for (int i = 0; i < HEIGHT; i++)
	{
		for (int j = 0; j < WIDTH; j++)
		{
			img.buf[i][j] = 0;
		}
	}

	for (int i = 0; i < 8; i++)
	{
		for (int j = 0; j < TEXT_HEIGHT * texWIDTH; j++)
		{
			img.texture[i][j] = 0;
		}
	}

	for (int x = 0; x < texWIDTH; x++)
	{
		for (int y = 0; y < TEXT_HEIGHT; y++)
		{
			int xorcolor = (x * 256 / texWIDTH) ^ (y * 256 / TEXT_HEIGHT);
			int ycolor = y * 256 / TEXT_HEIGHT;
			int xycolor = y * 128 / TEXT_HEIGHT + x * 128 / texWIDTH;
			img.texture[0][texWIDTH * y + x] = 65536 * 254 * (x != y && x != texWIDTH - y); //flat red texture with black cross
			img.texture[1][texWIDTH * y + x] = xycolor + 256 * xycolor + 65536 * xycolor; //sloped greyscale
			img.texture[2][texWIDTH * y + x] = 256 * xycolor + 65536 * xycolor; //sloped yellow gradient
			img.texture[3][texWIDTH * y + x] = xorcolor + 256 * xorcolor + 65536 * xorcolor; //xor greyscale
			// img.texture[4][texWIDTH * y + x] = 256 * xorcolor; //xor green
			// img.texture[5][texWIDTH * y + x] = 65536 * 192 * (x % 16 && y % 16); //red bricks
			// img.texture[6][texWIDTH * y + x] = 65536 * ycolor; //red gradient
			// img.texture[7][texWIDTH * y + x] = 128 + 256 * 128 + 65536 * 128; //flat grey texture
		}
	}

	img.moveSpeed = 0.05;
	img.rotSpeed = 0.05;
	
	img.win = mlx_new_window(img.mlx, WIDTH, HEIGHT, "mlx");

	img.img.img = mlx_new_image(img.mlx, WIDTH, HEIGHT);
	img.img.data = (int *)mlx_get_data_addr(img.img.img, &img.img.bpp, &img.img.size_l, &img.img.endian);
	main_loop(&img);
	mlx_key_hook(img.win, &key_press, &img);
// 	mlx_loop_hook(img.mlx, &main_loop, &img);
// 	mlx_hook(img.win, X_EVENT_KEY_PRESS, 0, &key_press, &img);

	mlx_loop(img.mlx);
}





test avec F et n importe quoi derriere fonctionne et ne devrait pas ouvrir la map
pareil avec les autres "NOsdfdvsd    ./maps/north.xpm" fonctionne 
test ./cub3D segfault
test couleur "F     1a, 9, 0" fonctionne du coup on peut ecrire des betises "F     1, 9-984984, 25"
test couleur "F     1, 9, 2 5" fonctionne 
test de map 	111111111111	met un map error et je sais pas tu peux essayer de le negocier	
				111100001111	mais dans le sujet c est ecrit que les espaces sont des caracteres
				111111N11 11	valables de la map et qu il faut les gerer correctement.
				1111000011111	Pour moi, tout du moins, ca signifie que les espaces sont du vide et 
				111111111111	quon ne peut donc pas y acceder mais on ne peut pas apres a toi de voir

/*
** OTHER cub3D
*/

typedef	struct	s_player
{
	float	x;
	float	y;
	float	angle;
	float	fov;
	float	speed;
	int		key_id[NB_INPUT];
	bool	input[NB_INPUT];
	int		map[2];
	int		step[2];
	double	sidedist[2];
	double	deltadist[2];
}				t_player;

void	ft_set_ray(t_prm_pkg *cub, t_ray_x *ray)
{
	ray->map[0] = (int)cub->player->x;
	ray->map[1] = (int)cub->player->y;
	ray->deltadist[0] = abs(1 / ray->eye_x);
	ray->deltadist[1] = abs(1 / ray->eye_y);
	if (ray->eye_x < 0)
	{
		ray->step[0] = -1;
		ray->sidedist[0] = (cub->player->x - map[0])
			* ray->deltadist[0];
	}
	else
	{
		ray->step[0] = 1;
		ray->sidedist[0] = cub->(ray->map[0] + 1.0 - cub->player->x)
			* ray->deltadist[0];
	}
	if (ray->eye_y < 0)
	{
		ray->step[1] = -1;
		ray->sidedist[0] = (cub->player->y - ray->map[1])
			* ray->deltadist[1];
	}
	else
	{
		ray->step[1] = 1;
		ray->sidedist[0] = (ray->map[1] + 1.0 - cub->player->y)
			* ray->deltadist[1];
	}
}

void	dda_algorithm(t_prm_pkg *cub, t_ray_x *ray)
{
	int	hit;
	int	side;

	hit = 0;
	while (hit == 0)
	{
		if (ray->sidedist[0] < ray->sidedist[1])
		{
			ray->sidedist[0] += ray->deltadist[0];
			ray->map[0] += ray->step[0];
			side = 0;
		}
		else
		{
			ray->sidedist[1] += ray->deltadist[1];
			ray->map[1] += ray->step[1];
			side = 1;
		}
		if (cub->config->map.data[map[0]][map[1]] > 0)
			hit = 1;
	}
}

/*
**
*/
void	draw(t_info *info)
{
	for (int y = 0; y < height; y++)
	{
		for (int x = 0; x < width; x++)
		{
			info->img.data[y * width + x] = info->buf[y][x];
		}
	}
	mlx_put_image_to_window(info->mlx, info->win, info->img.img, 0, 0);
}

void	calc(t_info *info)
{
	int	x;

	x = 0;
	if (info->re_buf == 1)
	{
		for (int i = 0; i < height; i++)
		{
			for (int j = 0; j < width; j++)
			{
				info->buf[i][j] = 0;
			}
		}
		info->re_buf = 0;
	}
	while (x < width)
	{
		double cameraX = 2 * x / (double)width - 1;
		double rayDirX = info->dirX + info->planeX * cameraX;
		double rayDirY = info->dirY + info->planeY * cameraX;
		
		int mapX = (int)info->posX;
		int mapY = (int)info->posY;

		//length of ray from current position to next x or y-side
		double sideDistX;
		double sideDistY;
		
		 //length of ray from one x or y-side to next x or y-side
		double deltaDistX = fabs(1 / rayDirX);
		double deltaDistY = fabs(1 / rayDirY);
		double perpWallDist;
		
		//what direction to step in x or y-direction (either +1 or -1)
		int stepX;
		int stepY;
		
		int hit = 0; //was there a wall hit?
		int side; //was a NS or a EW wall hit?

		if (rayDirX < 0)
		{
			stepX = -1;
			sideDistX = (info->posX - mapX) * deltaDistX;
		}
		else
		{
			stepX = 1;
			sideDistX = (mapX + 1.0 - info->posX) * deltaDistX;
		}
		if (rayDirY < 0)
		{
			stepY = -1;
			sideDistY = (info->posY - mapY) * deltaDistY;
		}
		else
		{
			stepY = 1;
			sideDistY = (mapY + 1.0 - info->posY) * deltaDistY;
		}

		while (hit == 0)
		{
			//jump to next map square, OR in x-direction, OR in y-direction
			if (sideDistX < sideDistY)
			{
				sideDistX += deltaDistX;
				mapX += stepX;
				side = 0;
			}
			else
			{
				sideDistY += deltaDistY;
				mapY += stepY;
				side = 1;
			}
			//Check if ray has hit a wall
			if (worldMap[mapX][mapY] > 0) hit = 1;
		}
		if (side == 0)
			perpWallDist = (mapX - info->posX + (1 - stepX) / 2) / rayDirX;
		else
			perpWallDist = (mapY - info->posY + (1 - stepY) / 2) / rayDirY;

		//Calculate height of line to draw on screen
		int lineHeight = (int)(height / perpWallDist);

		//calculate lowest and highest pixel to fill in current stripe
		int drawStart = -lineHeight / 2 + height / 2;
		if(drawStart < 0)
			drawStart = 0;
		int drawEnd = lineHeight / 2 + height / 2;
		if(drawEnd >= height)
			drawEnd = height - 1;

		// texturing calculations
		int texNum = worldMap[mapX][mapY];

		// calculate value of wallX
		double wallX;
		if (side == 0)
			wallX = info->posY + perpWallDist * rayDirY;
		else
			wallX = info->posX + perpWallDist * rayDirX;
		wallX -= floor(wallX);

		// x coordinate on the texture
		int texX = (int)(wallX * (double)texWidth);
		if (side == 0 && rayDirX > 0)
			texX = texWidth - texX - 1;
		if (side == 1 && rayDirY < 0)
			texX = texWidth - texX - 1;

		// How much to increase the texture coordinate perscreen pixel
		double step = 1.0 * texHeight / lineHeight;
		// Starting texture coordinate
		double texPos = (drawStart - height / 2 + lineHeight / 2) * step;
		for (int y = drawStart; y < drawEnd; y++)
		{
			// Cast the texture coordinate to integer, and mask with (texHeight - 1) in case of overflow
			int texY = (int)texPos & (texHeight - 1);
			texPos += step;
			int color = info->texture[texNum][texHeight * texY + texX];
			// make color darker for y-sides: R, G and B byte each divided through two with a "shift" and an "and"
			if (side == 1)
				color = (color >> 1) & 8355711;
			info->buf[y][x] = color;
			info->re_buf = 1;
		}
		x++;
	}
}

int	main_loop(t_info *info)
{
	calc(info);
	draw(info);
	return (0);
}

int	key_press(int key, t_info *info)
{
	if (key == K_W)
	{
		if (!worldMap[(int)(info->posX + info->dirX * info->moveSpeed)][(int)(info->posY)])
			info->posX += info->dirX * info->moveSpeed;
		if (!worldMap[(int)(info->posX)][(int)(info->posY + info->dirY * info->moveSpeed)])
			info->posY += info->dirY * info->moveSpeed;
	}
	//move backwards if no wall behind you
	if (key == K_S)
	{
		if (!worldMap[(int)(info->posX - info->dirX * info->moveSpeed)][(int)(info->posY)])
			info->posX -= info->dirX * info->moveSpeed;
		if (!worldMap[(int)(info->posX)][(int)(info->posY - info->dirY * info->moveSpeed)])
			info->posY -= info->dirY * info->moveSpeed;
	}
	//rotate to the right
	if (key == K_D)
	{
		//both camera direction and camera plane must be rotated
		double oldDirX = info->dirX;
		info->dirX = info->dirX * cos(-info->rotSpeed) - info->dirY * sin(-info->rotSpeed);
		info->dirY = oldDirX * sin(-info->rotSpeed) + info->dirY * cos(-info->rotSpeed);
		double oldPlaneX = info->planeX;
		info->planeX = info->planeX * cos(-info->rotSpeed) - info->planeY * sin(-info->rotSpeed);
		info->planeY = oldPlaneX * sin(-info->rotSpeed) + info->planeY * cos(-info->rotSpeed);
	}
	//rotate to the left
	if (key == K_A)
	{
		//both camera direction and camera plane must be rotated
		double oldDirX = info->dirX;
		info->dirX = info->dirX * cos(info->rotSpeed) - info->dirY * sin(info->rotSpeed);
		info->dirY = oldDirX * sin(info->rotSpeed) + info->dirY * cos(info->rotSpeed);
		double oldPlaneX = info->planeX;
		info->planeX = info->planeX * cos(info->rotSpeed) - info->planeY * sin(info->rotSpeed);
		info->planeY = oldPlaneX * sin(info->rotSpeed) + info->planeY * cos(info->rotSpeed);
	}
	if (key == K_ESC)
		exit(0);
	mlx_clear_window(info->mlx, info->win);
	main_loop(info);
	return (0);
}

int	main(void)
{
	t_info info;
	info.mlx = mlx_init();

	info.posX = 22.0;
	info.posY = 11.5;
	info.dirX = -1.0;
	info.dirY = 0.0;
	info.planeX = 0.0;
	info.planeY = 0.66;
	info.re_buf = 0;

	info.buf = (int **)malloc(sizeof(int *) * height);
	for (int i = 0; i < height; i++)
	{
		info.buf[i] = (int *)malloc(sizeof(int) * width);
	}

	for (int i = 0; i < height; i++)
	{
		for (int j = 0; j < width; j++)
		{
			info.buf[i][j] = 0;
		}
	}

	for (int i = 0; i < 8; i++)
	{
		for (int j = 0; j < texHeight * texWidth; j++)
		{
			info.texture[i][j] = 0;
		}
	}

	for (int x = 0; x < texWidth; x++)
	{
		for (int y = 0; y < texHeight; y++)
		{
			int xorcolor = (x * 256 / texWidth) ^ (y * 256 / texHeight);
			int ycolor = y * 256 / texHeight;
			int xycolor = y * 128 / texHeight + x * 128 / texWidth;
			info.texture[0][texWidth * y + x] = 65536 * 254 * (x != y && x != texWidth - y); //flat red texture with black cross
			info.texture[1][texWidth * y + x] = xycolor + 256 * xycolor + 65536 * xycolor; //sloped greyscale
			info.texture[2][texWidth * y + x] = 256 * xycolor + 65536 * xycolor; //sloped yellow gradient
			info.texture[3][texWidth * y + x] = xorcolor + 256 * xorcolor + 65536 * xorcolor; //xor greyscale
			info.texture[4][texWidth * y + x] = 256 * xorcolor; //xor green
			info.texture[5][texWidth * y + x] = 65536 * 192 * (x % 16 && y % 16); //red bricks
			info.texture[6][texWidth * y + x] = 65536 * ycolor; //red gradient
			info.texture[7][texWidth * y + x] = 128 + 256 * 128 + 65536 * 128; //flat grey texture
		}
	}

	info.moveSpeed = 0.05;
	info.rotSpeed = 0.05;
	
	info.win = mlx_new_window(info.mlx, width, height, "mlx");

	info.img.img = mlx_new_image(info.mlx, width, height);
	info.img.data = (int *)mlx_get_data_addr(info.img.img, &info.img.bpp, &info.img.size_l, &info.img.endian);
	main_loop(&info);
	mlx_key_hook(info.win, &key_press, &info);
// 	mlx_loop_hook(info.mlx, &main_loop, &info);
// 	mlx_hook(info.win, X_EVENT_KEY_PRESS, 0, &key_press, &info);

	mlx_loop(info.mlx);
}
